(use 'visualloy.util)
(random-float-portions 1 3)
(map + (random-float-portions 1 3))
(apply + (random-float-portions 1 3))
(use 'visualloy.util)
(apply + (random-float-portions 1 3))
(use 'visualloy.util)
(apply + (random-float-portions 1 3))
(random-float-portions 1 3)
(require 'seesaw.graphics)
(seesaw.graphics/buffered-image)
(seesaw.graphics/buffered-image 3 3)
(doc seesaw.graphics)
(doc 'seesaw.graphics)
seesaw.graphics
'seesaw.graphics
seesaw.graphics/->StringShape
(use 'seesaw.core)
(native!)
(def b (buffered-image 10 10))
(use 'seesaw.graphics)
(def b (buffered-image 10 10))
(-> b pack! show!)
(-> b show!)
(use 'seesaw.core 'seesaw.graphics 'seesaw.color)
(defn display 
  "Display a frame"
  [frame]
  (config! frame :on-close :exit)
  (show! frame))
(def a (make-alloy 100 250 100 20 3))
(defn t [m] (temperature->color yellow red (:temp m) 200))
(source t)
(source 't)
(doc t)
(t {:temp (long 9001) :comp [0.75 1.0 1.25])
(t {:temp (long 9001) :comp [0.75 1.0 1.25]})
(/ -448851 40)
(double (/ -448851 40))
(temperature->color yellow red 1000 10000)
(temperature->color yellow red 1000 100000)
yellow
red
(def green [0 255 0])
(def blue [0 0 255])
(temperature->color yellow red 1000 100000)
(temperature->color yellow blue 1000 100000)
(use 'visualloy.util)
(interpolate-value 0 100 500 1000)
(interpolate-value 0 100 700 1000)
(interpolate-value 0 100 1000 1000)
(interpolate-value 0 100 1001 1000)
(temperature->color yellow blue 1000 100000)
(temperature->color yellow blue 1000 1000000)
100/1
100/2
100/10
4/3
(type 4/3)
(doubl e(/ 5049 20))
(double (/ 5049 20))
yellow
blue
(interpolate-value 255 0 0.5)
(interpolate-value 255 0 0.4)
(interpolate-value 255 0 0.6)
(interpolate-value 255 0 0.9)
(partition 2 (interleave yellow red))
(interpolate-value 255 0 1.1)
(temperature->color yellow blue 1000 1000000)
(temperature->color yellow blue 1000 10000000)
(temperature->color yellow blue 1000 100)
(temperature->color yellow blue 1000 1000)
(temperature->color yellow blue 00 1000)
(temperature->color yellow blue 50 1000)
(for [c (temperature->color yellow blue 50 1000)] (int c))
(interleave [1 2] [3 4])
(concat [1 2] [3 4])
(concat [1 2] [3 4] [5 6])
(use 'visualloy.graphics)
(pixel 3 3)
 (concat
             (for [row (range h) col (range w)]
               [(pixel col row)
                (style :background (apply color
                                          (transform (aget arr row col))))]))
(def transform t)
 (concat
             (for [row (range h) col (range w)]
               [(pixel col row)
                (style :background (apply color
                                          (transform (aget arr row col))))]))
(def arr a)
 (concat
             (for [row (range h) col (range w)]
               [(pixel col row)
                (style :background (apply color
                                          (transform (aget arr row col))))]))
(def w 100) (def h 100)\
(def w 100) (def h 100)
 (concat
             (for [row (range h) col (range w)]
               [(pixel col row)
                (style :background (apply color
                                          (transform (aget arr row col))))]))
(def out  (concat
             (for [row (range h) col (range w)]
               [(pixel col row)
                (style :background (apply color
                                          (transform (aget arr row col))))])))
(first out)
(second out)
(concat (for [x (range 5) y (range 5)] [x y]))
(apply concat (for [x (range 5) y (range 5)] [x y]))
(get-neigbors)
(use 'visualloy.alloy)
(get-neigbors)
(for [dh [-1 0 1] dw [-1 0 1] :when (not= (Math/abs dh) (Math/abs dw))] [dh dw])
(type 0.1)
(type 0.1D)
(def a (make-alloy 32 64 100 20 3))
(deb b (aclone a))
(def b (aclone a))
(update-alloy a b [0.75 1.0 1.25)
(update-alloy a b [0.75 1.0 1.25])
b
a
(use 'visualloy.util)
(def dimn (dimensions a))
(let [[h w] dimn] (apply + (for [i (range h) j (range w)] (- (aget a i j) (aget b i j)))))
(let [[h w] dimn] (apply + (for [i (range h) j (range w)] (- (:temp (aget a i j)) (:temp (aget b i j))))))
(update-alloy a b [0.75 1.0 1.25])
(let [[h w] dimn] (apply + (for [i (range h) j (range w)] (- (:temp (aget a i j)) (:temp (aget b i j))))))
(update-alloy b a [0.75 1.0 1.25])
(let [[h w] dimn] (apply + (for [i (range h) j (range w)] (- (:temp (aget a i j)) (:temp (aget b i j))))))
ls
(ls)
(use 'visualloy.physics)
(temp-from-neighbors [{:temp 100 :comp [1.0]}] 1.0)
(temp-from-neighbors [{:temp 100 :comp [1.0]}] [1.0])
(temp-from-neighbors [{:temp 100 :comp [1.0]} {:temp 50 :comp [1.0]}] [1.0])
(temp-from-neighbors [{:temp 100 :comp [1.0]} {:temp 50 :comp [1.0]}] [1.5])
(temp-from-neighbors [{:temp 100 :comp [1.0]} {:temp 50 :comp [1.0]}] [2])
(use 'visualloy.alloy)
(def a (make-array 2 2))
(def a (make-array PersistentArrayMap 2 2))
(def a (make-array clojure.lang.PersistentArrayMap 2 2))
a
(aset a 0 0 {:temp 100 :comp [1.0]})
a
(aset a 0 1 {:temp 50 :comp [1.0]})
(aset a 1 1 {:temp 150 :comp [1.0]})
(aset a 1 0 {:temp 0 :comp [1.0]})
(use 'visualloy.util)
(dimensions a)
(get-neighbors a 0 0)
(get-neighbors a 0 1)
(show-alloy a)
(get-neighbors a 0 1)
(set-temperature a 0 0 101)
a
(show-alloy a)
(def b (aclone a))
(show-alloy a)
(show-alloy b)
(update-alloy a b [1.0])
(show-alloy a)
(show-alloy b)
(aset a 0 0 0)
(aset a 0 0 {:temp 0 :comp [1.0]})
(show-alloy a)
(show-alloy b)
(def d (make-array int 1 1)
)
(def d (make-array Integer 1 1))
(def e (aclone d))
e
a
d
e
d
(show-alloy e)
(show-alloy d)
(aset d 0 0 1)
(aset d 0 0 (int 1))
(show-alloy d)
(show-alloy e)
(aset d 1 1 (int 1))
(aget d 0 0 )
(print-alloy e)
(print-alloy d)
d
e
(aget e 0 0 )
(repeat 2 [a])
(repeatedly 2 [a])
(repeatedly [a])
(time (let [a (make-array Integer/TYPE 2 2) [x y] (repeat 2 a)))
(time (let [a (make-array Integer/TYPE 2 2) [x y] (repeat 2 a)]))
(time (let [a (make-array Integer/TYPE 2 2) [x y] (repeat a)]))
(time (let [[x y] (repeatedly #(make-array Integer/TYPE 2 2))]))
(time (let [[x y] (repeatedly 2 #(make-array Integer/TYPE 2 2))]))
(doc repeatedly)
(run)
(def alloy (make-alloy 100 100 100 90 3))
(def A (to-array-2d alloy))
A
(def B (to-array-2d alloy))
(print-alloy A)
(def alloy (make-alloy 20 20 100 90 3))
(def A (to-array-2d alloy))
(def B (to-array-2d alloy))
(print-alloy A)
(def C [0.75 1.0 1.25])
(update-alloy A B C)
(print-alloy A)
(print-alloy B)
(update-alloy B A C)
(print-alloy B)
(print-alloy A)
(def alloy (make-alloy 20 20 100000 90 3))
(def A (to-array-2d alloy))
(def B (to-array-2d alloy))
(print-alloy A)
(update-alloy A B C)
(print-alloy A)
(print-alloy B)
(update-alloy B A C)
(print-alloy A)
(update-alloy A B C)
(update-alloy B A C)
(update-alloy A B C)
(update-alloy B A C)
(print-alloy A)
(use 'seesaw.core)
(def f (frame :title "ffffrrrraaaammmmeeee"))
(defn display [f] (-> f pack! show!))
(display f)
(native!)
(display f)
(def f (frame :title "Get to know Seesaw"))
(display f)
(use 'visualloy.graphics)
(display f)
(-> f pack! show!)
(def lbl (label "I'm another label"))
(config! f :content lbl)
(defn display [content]
(config! f :content content)
content)
(defn display-content [content]
(config! f :content content)
content)
(display-content lbl)
(display f)
(display-content lbl)
(display f)
(alert "alkdfjlsjdfklj")
(bit-shift-right (+ 1 10) 1)
(flatten [[1 2 3][2 3][[4]]])
(flatten 2.0)
(concat 2.0 30)
(flatten 2.0 3.0)
(apply flatten 2.0 3.0)
(map + 1 2 3)
(map + 1 2 3 [3])
(doc isa?
)
(use 'visualloy.util)
(midpoint 0 10)
(midpoint 1 10)
(midpoint 2 10)
(midpoint 9 10)
(midpoint 10 10)
(area)
(area 0 1 0 1)
(area 0 2 0 2)
(area 0 2 0 3)
(use 'visualloy.util)
(interpolate-value 0 255 0 Long/MAX_VALUE)
(interpolate-value 0 255 (/ Long/MAX_VALUE 2) Long/MAX_VALUE)
(interpolate-value 0 255 1000 10)
(interpolate-value 0 255 -1000 10)
*1
(map double [1 2 3])
(apply double [1 2 3])
(Double 3)
(Double. 3)
(Double. "3")
(doc when)
(count (for [i (range 100)] (when true i)))
(count (for [i (range 100)] (when (< i 50) i)))
(apply + (for [i (range 100)] (when (< i 50) i)))
(for [i (range 100)] (when (< i 50) i))
(require '[clojure.core.reducers :as r])
(doc r/map)
(doc map)
(r/map + [1 2 3])
(reduce (r/map + [1 2 3]))
(reduce + (r/map + [1 2 3]))
(r/map [1 2 3])
((r/map [1 2 3]) +
)
(reduce + ((r/map [1 2 3]) +)
)
(doc pmap)
